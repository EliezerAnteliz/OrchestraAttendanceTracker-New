import React, { useCallback, useEffect, useState, memo, useMemo } from 'react';
import { View, FlatList, RefreshControl, StyleSheet, Alert } from 'react-native';
import { ActivityIndicator, Appbar, Portal, Dialog, Button, Text, Surface, List, IconButton, Chip } from 'react-native-paper';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { supabase } from '../config/supabase';
import { useRouter } from 'expo-router';
import { theme } from '../theme';
import StudentItem from '../components/StudentItem';
import { useFocusEffect } from '@react-navigation/native';
import { ScrollView } from 'react-native-gesture-handler';

// IDs correctos de la base de datos
const ORGANIZATION_ID = 'a0d1e7a6-87ad-45d1-9cb5-f08f083f24c4';
const PROGRAM_ID = '9d7dc91c-7bbe-49cd-bc64-755467bf91da';

const CACHE_KEYS = {
    STUDENTS: 'cached_students',
    ATTENDANCE: 'cached_attendance',
    LAST_FETCH: 'last_fetch_timestamp'
};

const CACHE_DURATION = 1000 * 60 * 5; // 5 minutos

const StudentsListScreen = () => {
    const router = useRouter();
    const [students, setStudents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [refreshing, setRefreshing] = useState(false);
    const [attendanceStatus, setAttendanceStatus] = useState({});
    const [isAttendanceMode, setIsAttendanceMode] = useState(false);
    const [selectedStudents, setSelectedStudents] = useState(new Set());
    const [showAttendanceDialog, setShowAttendanceDialog] = useState(false);
    const [isLoadingFromCache, setIsLoadingFromCache] = useState(true);
    const [selectedInstrument, setSelectedInstrument] = useState('all');
    const [instruments, setInstruments] = useState([]);

    // Cargar datos desde caché
    const loadFromCache = useCallback(async () => {
        try {
            const cachedStudents = await AsyncStorage.getItem(CACHE_KEYS.STUDENTS);
            const cachedAttendance = await AsyncStorage.getItem(CACHE_KEYS.ATTENDANCE);
            
            if (cachedStudents && cachedAttendance) {
                setStudents(JSON.parse(cachedStudents));
                setAttendanceStatus(JSON.parse(cachedAttendance));
                setLoading(false);
            }
            
            // Siempre fetchear datos frescos después de cargar el caché
            fetchStudents(false);
        } catch (error) {
            console.error('Error loading from cache:', error);
            fetchStudents(true);
        }
    }, []);

    // Guardar datos en caché
    const saveToCache = useCallback(async (studentsData, attendanceData) => {
        try {
            await Promise.all([
                AsyncStorage.setItem(CACHE_KEYS.STUDENTS, JSON.stringify(studentsData)),
                AsyncStorage.setItem(CACHE_KEYS.ATTENDANCE, JSON.stringify(attendanceData)),
                AsyncStorage.setItem(CACHE_KEYS.LAST_FETCH, Date.now().toString())
            ]);
        } catch (error) {
            console.error('Error saving to cache:', error);
        }
    }, []);

    // Obtener asistencia para una fecha específica
    const fetchAttendanceForDate = async (date) => {
        const { data, error } = await supabase
            .from('attendance')
            .select('*')
            .eq('date', date);

        if (error) {
            console.error('Error fetching attendance:', error);
            return {};
        }

        return data.reduce((acc, record) => {
            acc[record.student_id] = record.status_code;
            return acc;
        }, {});
    };

    // Cargar estudiantes y asistencia
    const fetchStudents = useCallback(async (showLoader = true) => {
        if (showLoader) {
            setLoading(true);
        }

        try {
            const today = new Date().toISOString().split('T')[0];
            const [studentsResponse, attendanceResponse] = await Promise.all([
                supabase
                    .from('students')
                    .select('*')
                    .eq('organization_id', ORGANIZATION_ID)
                    .eq('program_id', PROGRAM_ID)
                    .eq('is_active', true)
                    .order('first_name', { ascending: true }),
                supabase
                    .from('attendance')
                    .select('*')
                    .eq('date', today)
            ]);

            if (studentsResponse.error) throw studentsResponse.error;
            if (attendanceResponse.error) throw attendanceResponse.error;

            const attendanceMap = {};
            attendanceResponse.data.forEach(record => {
                attendanceMap[record.student_id] = record.status_code;
            });

            setStudents(studentsResponse.data || []);
            setAttendanceStatus(attendanceMap);

            // Guardar en caché
            await Promise.all([
                AsyncStorage.setItem(CACHE_KEYS.STUDENTS, JSON.stringify(studentsResponse.data)),
                AsyncStorage.setItem(CACHE_KEYS.ATTENDANCE, JSON.stringify(attendanceMap))
            ]);
        } catch (error) {
            console.error('Error fetching students:', error);
            if (!students.length) {
                Alert.alert('Error', 'No se pudieron cargar los estudiantes');
            }
        } finally {
            setLoading(false);
            setRefreshing(false);
        }
    }, []);

    // Cargar instrumentos
    const loadInstruments = useCallback(async () => {
        try {
            const { data, error } = await supabase
                .from('students')
                .select('instrument')
                .not('instrument', 'is', null);

            if (error) throw error;

            // Orden específico para los instrumentos
            const instrumentOrder = ['Violin', 'Viola', 'Cello', 'Bass', 'Not assigned'];
            
            // Obtener instrumentos únicos
            const uniqueInstruments = [...new Set(data.map(item => item.instrument))];
            
            // Ordenar los instrumentos según el orden especificado
            const sortedInstruments = uniqueInstruments.sort((a, b) => {
                const indexA = instrumentOrder.indexOf(a);
                const indexB = instrumentOrder.indexOf(b);
                
                if (indexA >= 0 && indexB >= 0) {
                    return indexA - indexB;
                }
                if (indexA >= 0) return -1;
                if (indexB >= 0) return 1;
                return a.localeCompare(b);
            });

            setInstruments(sortedInstruments);
        } catch (error) {
            console.error('Error cargando instrumentos:', error);
        }
    }, []);

    // Inicialización
    useEffect(() => {
        loadFromCache();
        loadInstruments();
    }, [loadFromCache, loadInstruments]);

    // Actualizar al obtener foco
    useFocusEffect(
        useCallback(() => {
            fetchStudents(false);
        }, [fetchStudents])
    );

    // Manejar refresh
    const handleRefresh = useCallback(() => {
        setRefreshing(true);
        fetchStudents(false);
    }, [fetchStudents]);

    // Manejar cambio de estado de asistencia
    const handleStatusChange = useCallback(async (studentId, status) => {
        try {
            const today = new Date().toISOString().split('T')[0];
            
            const { data: existingRecord, error: checkError } = await supabase
                .from('attendance')
                .select('*')
                .eq('student_id', studentId)
                .eq('date', today)
                .single();

            if (checkError && checkError.code !== 'PGRST116') {
                throw checkError;
            }

            if (existingRecord) {
                const { error: updateError } = await supabase
                    .from('attendance')
                    .update({ 
                        status_code: status,
                        updated_at: new Date().toISOString()
                    })
                    .eq('student_id', studentId)
                    .eq('date', today);

                if (updateError) throw updateError;
            } else {
                const { error: insertError } = await supabase
                    .from('attendance')
                    .insert({
                        student_id: studentId,
                        date: today,
                        status_code: status,
                        updated_at: new Date().toISOString()
                    });

                if (insertError) throw insertError;
            }

            // Recargar los datos después de la actualización
            fetchStudents();
        } catch (error) {
            console.error('Error updating attendance:', error);
            Alert.alert('Error', 'No se pudo actualizar la asistencia');
        }
    }, [fetchStudents]);

    // Manejar selección de estudiantes
    const toggleStudentSelection = useCallback((studentId) => {
        setSelectedStudents(prev => {
            const newSet = new Set(prev);
            if (newSet.has(studentId)) {
                newSet.delete(studentId);
            } else {
                newSet.add(studentId);
            }
            return newSet;
        });
    }, []);

    // Filtrado optimizado
    const filteredStudents = useMemo(() => {
        if (selectedInstrument === 'all') return students;
        return students.filter(student => student.instrument === selectedInstrument);
    }, [students, selectedInstrument]);

    // Optimizaciones para FlatList
    const keyExtractor = useCallback((item) => item.id.toString(), []);

    const renderItem = useCallback(({ item }) => (
        <StudentItem
            key={item.id}
            item={item}
            onPress={() => handleStudentPress(item)}
            isSelected={selectedStudents.has(item.id)}
            status={attendanceStatus[item.id] || ''}
            attendanceMode={isAttendanceMode}
        />
    ), [selectedStudents, isAttendanceMode, attendanceStatus, handleStudentPress]);

    const ListEmptyComponent = useCallback(() => (
        <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
                No hay estudiantes para el instrumento seleccionado
            </Text>
        </View>
    ), []);

    const getItemLayout = useCallback((data, index) => ({
        length: 80, // Altura aproximada de cada elemento
        offset: 80 * index,
        index,
    }), []);

    // Manejar presión en estudiante
    const handleStudentPress = (student) => {
        if (isAttendanceMode) {
            // Si estamos en modo asistencia, manejamos la selección
            toggleStudentSelection(student.id);
        } else {
            // Si no estamos en modo asistencia, navegamos al perfil
            router.push({
                pathname: `/student/${student.id}`,
                params: {
                    firstName: student.first_name,
                    lastName: student.last_name,
                    grade: student.current_grade,
                    age: student.age,
                    instrument: student.instrument,
                    position: student.orchestra_position,
                }
            });
        }
    };

    // Optimizar la selección múltiple
    const selectAllStudents = useCallback(() => {
        const allIds = new Set(
            filteredStudents.map(student => student.id)
        );
        setSelectedStudents(allIds);
    }, [filteredStudents]);

    // Función para deseleccionar todos
    const deselectAllStudents = useCallback(() => {
        setSelectedStudents(new Set());
    }, []);

    const styles = StyleSheet.create({
        container: {
            flex: 1,
            backgroundColor: theme.colors.background,
        },
        loaderContainer: {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: theme.colors.background,
        },
        loaderText: {
            marginTop: 8,
            color: theme.colors.primary,
            fontSize: 16,
        },
        listContent: {
            paddingVertical: 8,
        },
        emptyList: {
            flexGrow: 1,
        },
        emptyContainer: {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            padding: 32,
            marginTop: '50%',
        },
        emptyText: {
            textAlign: 'center',
            fontSize: 16,
            color: theme.colors.placeholder,
        },
        dialog: {
            backgroundColor: theme.colors.surface,
            borderRadius: 8,
            maxHeight: '80%',
        },
        dialogTitle: {
            fontSize: 18,
            fontWeight: 'bold',
            marginBottom: 8,
        },
        dialogText: {
            textAlign: 'center',
            marginBottom: 24,
            fontSize: 16,
        },
        dialogActions: {
            flexDirection: 'column',
            padding: 24,
            gap: 8,
        },
        button: {
            width: '100%',
            marginVertical: 4,
        },
        filterContainer: {
            padding: 16,
            marginHorizontal: 16,
            marginVertical: 16,
            borderRadius: 8,
            elevation: 2,
        },
        sectionLabel: {
            fontSize: 16,
            marginBottom: 8,
            fontWeight: '500',
        },
        instrumentsScroll: {
            flexGrow: 0,
        },
        instrumentChip: {
            marginRight: 8,
            marginVertical: 4,
        },
        header: {
            backgroundColor: 'white',
            elevation: 2,
        },
    });

    return (
        <View style={styles.container}>
            {/* Cabecera */}
            <Appbar.Header style={styles.header}>
                <Appbar.Content title="Lista de Estudiantes" />
                {isAttendanceMode ? (
                    <>
                        <Appbar.Action 
                            icon="select-all" 
                            onPress={selectAllStudents}
                            iconColor={theme.colors.primary}
                            tooltip="Seleccionar todos"
                        />
                        <Appbar.Action 
                            icon="checkbox-blank-outline" 
                            onPress={deselectAllStudents}
                            tooltip="Deseleccionar todos"
                        />
                        <Appbar.Action 
                            icon="check-all" 
                            onPress={() => setShowAttendanceDialog(true)}
                            disabled={selectedStudents.size === 0}
                            tooltip="Marcar asistencia"
                        />
                        <Appbar.Action 
                            icon="close" 
                            onPress={() => {
                                setIsAttendanceMode(false);
                                setSelectedStudents(new Set());
                            }} 
                            tooltip="Cancelar selección"
                        />
                    </>
                ) : (
                    <Appbar.Action 
                        icon="clipboard-check" 
                        onPress={() => setIsAttendanceMode(true)}
                        tooltip="Tomar asistencia de hoy"
                    />
                )}
            </Appbar.Header>

            {/* Filtro de instrumentos */}
            <Surface style={styles.filterContainer}>
                <Text style={styles.sectionLabel}>Filtrar por Instrumento:</Text>
                <ScrollView 
                    horizontal 
                    showsHorizontalScrollIndicator={false} 
                    style={styles.instrumentsScroll}
                >
                    <Chip
                        selected={selectedInstrument === 'all'}
                        onPress={() => setSelectedInstrument('all')}
                        style={styles.instrumentChip}
                        mode="outlined"
                    >
                        Todos
                    </Chip>
                    {instruments.map((instrument) => (
                        <Chip
                            key={instrument}
                            selected={selectedInstrument === instrument}
                            onPress={() => setSelectedInstrument(instrument)}
                            style={styles.instrumentChip}
                            mode="outlined"
                        >
                            {instrument}
                        </Chip>
                    ))}
                </ScrollView>
            </Surface>

            {/* Lista de estudiantes */}
            {loading ? (
                <View style={styles.loaderContainer}>
                    <ActivityIndicator size="large" color={theme.colors.primary} />
                    <Text style={styles.loaderText}>Cargando estudiantes...</Text>
                </View>
            ) : (
                <FlatList
                    data={filteredStudents}
                    renderItem={renderItem}
                    keyExtractor={keyExtractor}
                    getItemLayout={getItemLayout}
                    initialNumToRender={7}
                    maxToRenderPerBatch={5}
                    windowSize={3}
                    removeClippedSubviews={true}
                    updateCellsBatchingPeriod={50}
                    ListEmptyComponent={ListEmptyComponent}
                    maintainVisibleContentPosition={{
                        minIndexForVisible: 0,
                        autoscrollToTopThreshold: 10
                    }}
                    contentContainerStyle={[
                        styles.listContent,
                        !filteredStudents.length && styles.emptyList
                    ]}
                    refreshControl={
                        <RefreshControl
                            refreshing={refreshing}
                            onRefresh={handleRefresh}
                            colors={[theme.colors.primary]}
                        />
                    }
                />
            )}

            {/* Diálogo de asistencia */}
            <Portal>
                <Dialog
                    visible={showAttendanceDialog}
                    onDismiss={() => setShowAttendanceDialog(false)}
                    style={styles.dialog}
                >
                    <Dialog.Title style={styles.dialogTitle}>Marcar Asistencia</Dialog.Title>
                    <Dialog.Content>
                        <Text style={styles.dialogText}>
                            ¿Qué estado deseas asignar a los {selectedStudents.size} estudiantes seleccionados?
                        </Text>
                    </Dialog.Content>
                    <Dialog.Actions style={styles.dialogActions}>
                        <Button 
                            mode="contained" 
                            onPress={() => {
                                Array.from(selectedStudents).forEach(id => handleStatusChange(id, 'A'));
                                setShowAttendanceDialog(false);
                                setSelectedStudents(new Set());
                                setIsAttendanceMode(false);
                            }}
                            style={styles.button}
                            buttonColor={theme.colors.attendance.present}
                        >
                            Presente (A)
                        </Button>
                        <Button 
                            mode="contained"
                            onPress={() => {
                                Array.from(selectedStudents).forEach(id => handleStatusChange(id, 'EA'));
                                setShowAttendanceDialog(false);
                                setSelectedStudents(new Set());
                                setIsAttendanceMode(false);
                            }}
                            style={styles.button}
                            buttonColor={theme.colors.attendance.justified}
                        >
                            Ausencia Justificada (EA)
                        </Button>
                        <Button 
                            mode="contained"
                            onPress={() => {
                                Array.from(selectedStudents).forEach(id => handleStatusChange(id, 'UA'));
                                setShowAttendanceDialog(false);
                                setSelectedStudents(new Set());
                                setIsAttendanceMode(false);
                            }}
                            style={styles.button}
                            buttonColor={theme.colors.attendance.unexcused}
                        >
                            Ausencia Injustificada (UA)
                        </Button>
                        <Button 
                            mode="outlined"
                            onPress={() => setShowAttendanceDialog(false)}
                            style={styles.button}
                        >
                            Cancelar
                        </Button>
                    </Dialog.Actions>
                </Dialog>
            </Portal>
        </View>
    );
};

export default memo(StudentsListScreen);
